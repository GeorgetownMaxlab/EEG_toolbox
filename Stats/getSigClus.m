function [data_sig, sigClusters] = getSigClus(data,dataperm,elecLocs,alpha,alpha_clus)
% function data_sig = getSigClus(data,dataperm,elecLocs,alpha,sigVal) 
% This function performs spatiotemporal cluster correction. See Maris E., Oostenveld R. J Neurosci Methods. 2007
%
% Input:
%   - data: data matrix in the form of data(chan,time)
%   - dataperm: data with empirical distribution generated by shuffling labels in the form: dataperm(chan,time,perms)
%   - elecLocs: NX3 matrix of electrode locations
%   - thresh: used to determine spatio-temporal neigborhood. Can either be a radius or the number of neighbors
%   - alpha: initial threshold used for cluster formation
%   - alpha_clus: actual significance threshold used to determine if a cluster is significant
%
% Output:
%   - data_sig: same as data matrix, but all non-significant values are set to zero
%   - sigClusters: cell array containing the actual indices of the significant clusters
%

% Get neighborhood adjacency matrix
elecNbrs = getNbr(elecLocs,thresh,flag);

% Compute clusters in actual data
[data_clus,clusterIdx] = spatialClusGenerator(data,dataperm,alpha,elecNbrs);

% Find the the clusters with the largest mass(sum of values) for each permuted data set
parfor j = 1:size(dataperm,3) % iterate through each permutation
    dat = squeeze(dataperm(:,:,j));
    foo = spatialClusGenerator(dat,dataperm,alpha,elecNbrs);
    clusMassPerm(j)=max(foo); % distribution of clusters
end

% determine p-value for clusters in actual data set
for i = 1:length(data_clus)
    sigVals(i) = sum(data_clus(i)<=clusMassPerm)/length(clusMassPerm);
end

% Filter the data to include only significant clusters
sigIdx = find(sigVals<=alpha_clus);
data_sig = zeros(size(data));
for i = 1:length(sigIdx)
    idx = sigIdx(i);
    for j = 1:length(clusterIdx{idx}(:,2))
        elecsUsed = elecs{clusterIdx{idx}(j,1)};
        data_sig(elecsUsed,clusterIdx{idx}(j,2)) = data(clusterIdx{idx}(j,1),clusterIdx{idx}(j,2));
    end
end
clusterIdx = clusterIdx';
sigClusters = clusterIdx(sigIdx);

end

function elecNbrs = getNbr(elecLocs,thresh,flag)
% function elecNbrs = getNbr(elecLocs,alpha,flag)
% Returns the neighborhood structure in the form of an adjacency matrix that is used for cluster analysis
% Input:
%   - elecLocs: NX3 matrix of electrode locations
%   - alpha: either number of neighbors or radius 
%   - flag: determines the method
%       - KNN: picks the K-nearest neighbors to each electrode
%       - ROI: assigns all electrodes within a radius around a given electrode as neighbors
%
% Output:
%   - elecNbrs: adjacency matrix contining neighborhood information. Neighbors are marked with a  1
% 

elecDists = dist(elecLocs');
clc
switch flag
    case 'KNN'
        %% To  create searchlight using K-NN method
        for e = 1:size(elecLocs,1)
           foo = elecDists(e,:);
           [~,sortIdx] = sort(foo);
           elecGroups{e} = sortIdx(2:thresh);
        end
    case 'ROI'
    %% To create spherical ROIs
        filterElecDists = elecDists<thresh;
        for e = 1:size(elecLocs,1)
           foo = find(filterElecDists(e,:));
           filterElecLocs = elecLocs(foo,:);
           elecCurrent = elecLocs(e,:);
           elecGroups{e} = foo; 
        end
end

elecNbrs = zeros(size(elecLocs,1));
for i = 1:size(elecLocs,1)
    elecNbrs(i,elecs{i}) = 1;
end
